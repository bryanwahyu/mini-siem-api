package httpapi

import (
    "context"
    "encoding/json"
    "net/http"
    "time"

    "github.com/gorilla/mux"
    httpSwagger "github.com/swaggo/http-swagger"
    "github.com/rs/zerolog/log"

    "server-analyst/internal/application/usecases"
    cfg "server-analyst/internal/infrastructure/config"
    "server-analyst/internal/infrastructure/observability"
    "server-analyst/internal/infrastructure/security"
    "server-analyst/internal/domain/entities"
    "server-analyst/internal/domain/repositories"

    // docs is generated by Swag CLI, you have to import it.
    docs "server-analyst/docs"
    "strconv"
)

type Server struct {
    http *http.Server
    deps Deps
}

type Deps struct {
    Cfg            *cfg.Config
    ListEvents     *usecases.ListEventsQuery
    ListDecisions  *usecases.ListDecisionsQuery
    ListDetections *usecases.ListDetectionsQuery
    Action         *usecases.ApplyActionUsecase
}

func NewServer(d Deps) *Server {
    observability.InitMetrics()
    r := mux.NewRouter()
    r.Use(loggingMiddleware)
    // Swagger docs
    docs.SwaggerInfo.BasePath = "/"
    r.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)
    // Health
    r.HandleFunc("/health", sGetHealth).Methods(http.MethodGet)
    // Metrics
    r.Handle("/metrics", observability.MetricsHandler()).Methods(http.MethodGet)
    // Events / Decisions
    srv := &Server{deps: d}
    r.HandleFunc("/events", srv.getEvents).Methods(http.MethodGet)
    r.HandleFunc("/decisions", srv.getDecisions).Methods(http.MethodGet)
    r.HandleFunc("/detections", srv.getDetections).Methods(http.MethodGet)

    // Admin protected routes example (block/unblock)
    admin := r.PathPrefix("/decisions").Subrouter()
    admin.Use(security.APIKeyAuth(d.Cfg.Server.APIKey))
    admin.Use(security.NewRateLimiter(10, 2*time.Second).Limit)
    admin.HandleFunc("/block", srv.postDecisionBlock).Methods(http.MethodPost)
    admin.HandleFunc("/unblock", srv.postDecisionUnblock).Methods(http.MethodPost)

    hs := &http.Server{Addr: d.Cfg.Server.HTTPAddr, Handler: r}
    return &Server{http: hs, deps: d}
}

func (s *Server) Start() error {
    go func() {
        if err := s.http.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatal().Err(err).Msg("http server failed")
        }
    }()
    return nil
}

func (s *Server) Stop(ctx context.Context) error { return s.http.Shutdown(ctx) }

// keep references for swagger model generation
var (
    _ = entities.Event{}
    _ = entities.Decision{}
)

// sGetHealth godoc
// @Summary      Health check
// @Description  Returns service health
// @Tags         system
// @Produce      json
// @Success      200 {object} map[string]any
// @Router       /health [get]
func sGetHealth(w http.ResponseWriter, r *http.Request) {
    resp := map[string]any{"status": true, "message": "healthy", "code": 200, "data": nil}
    w.Header().Set("Content-Type", "application/json")
    _ = json.NewEncoder(w).Encode(resp)
}

// getEvents godoc
// @Summary      List events
// @Description  Returns recent events (max 100)
// @Tags         events
// @Produce      json
// @Success      200 {array} entities.Event
// @Router       /events [get]
func (s *Server) getEvents(w http.ResponseWriter, r *http.Request) {
    list := s.deps.ListEvents
    evs, err := list.Run(r.Context(), 100, 0)
    if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError); return }
    w.Header().Set("Content-Type", "application/json")
    _ = json.NewEncoder(w).Encode(evs)
}

// getDecisions godoc
// @Summary      List decisions
// @Description  Returns recent decisions (max 100)
// @Tags         decisions
// @Produce      json
// @Success      200 {array} entities.Decision
// @Router       /decisions [get]
func (s *Server) getDecisions(w http.ResponseWriter, r *http.Request) {
    list := s.deps.ListDecisions
    ds, err := list.Run(r.Context(), 100, 0)
    if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError); return }
    w.Header().Set("Content-Type", "application/json")
    _ = json.NewEncoder(w).Encode(ds)
}

// getDetections godoc
// @Summary      List detections
// @Description  Returns recent detections (max 100). "where" info is in Metadata (JSON: ip, path, host, source)
// @Tags         detections
// @Produce      json
// @Param        limit   query int false "max rows" default(100)
// @Param        offset  query int false "rows to skip" default(0)
// @Param        ip      query string false "filter by IP"
// @Param        host    query string false "filter by host"
// @Param        source  query string false "filter by source"
// @Param        category query string false "filter by category"
// @Param        rule    query string false "filter by rule"
// @Param        from    query string false "RFC3339 from time"
// @Param        to      query string false "RFC3339 to time"
// @Success      200 {array} entities.Detection
// @Router       /detections [get]
func (s *Server) getDetections(w http.ResponseWriter, r *http.Request) {
    // Parse pagination
    limit := 100
    offset := 0
    if v := r.URL.Query().Get("limit"); v != "" { if n, err := strconv.Atoi(v); err == nil && n > 0 && n <= 1000 { limit = n } }
    if v := r.URL.Query().Get("offset"); v != "" { if n, err := strconv.Atoi(v); err == nil && n >= 0 { offset = n } }
    var f repositories.DetectionFilter
    q := r.URL.Query()
    f.IP = q.Get("ip")
    f.Host = q.Get("host")
    f.Source = q.Get("source")
    f.Category = q.Get("category")
    f.Rule = q.Get("rule")
    if v := q.Get("from"); v != "" { if t, err := time.Parse(time.RFC3339, v); err == nil { f.From = &t } }
    if v := q.Get("to"); v != "" { if t, err := time.Parse(time.RFC3339, v); err == nil { f.To = &t } }
    list := s.deps.ListDetections
    ds, err := list.Run(r.Context(), &f, limit, offset)
    if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError); return }
    w.Header().Set("Content-Type", "application/json")
    _ = json.NewEncoder(w).Encode(ds)
}

// DecisionRequest is the request body for decision endpoints
type DecisionRequest struct{
    IP string `json:"ip"`
    Reason string `json:"reason"`
}

// postDecisionBlock godoc
// @Summary      Block IP
// @Description  Blocks an IP address via action adapters
// @Tags         decisions
// @Accept       json
// @Security     ApiKeyAuth
// @Param        request body DecisionRequest true "Block request"
// @Success      204
// @Failure      400 {string} string "bad request"
// @Failure      500 {string} string "internal error"
// @Router       /decisions/block [post]
func (s *Server) postDecisionBlock(w http.ResponseWriter, r *http.Request) {
    var req DecisionRequest
    _ = json.NewDecoder(r.Body).Decode(&req)
    if req.IP == "" { http.Error(w, "ip required", http.StatusBadRequest); return }
    if err := s.deps.Action.Block(r.Context(), req.IP, req.Reason); err != nil { http.Error(w, err.Error(), http.StatusInternalServerError); return }
    w.WriteHeader(http.StatusNoContent)
}

// postDecisionUnblock godoc
// @Summary      Unblock IP
// @Description  Unblocks an IP address via action adapters
// @Tags         decisions
// @Accept       json
// @Security     ApiKeyAuth
// @Param        request body DecisionRequest true "Unblock request"
// @Success      204
// @Failure      400 {string} string "bad request"
// @Failure      500 {string} string "internal error"
// @Router       /decisions/unblock [post]
func (s *Server) postDecisionUnblock(w http.ResponseWriter, r *http.Request) {
    var req DecisionRequest
    _ = json.NewDecoder(r.Body).Decode(&req)
    if req.IP == "" { http.Error(w, "ip required", http.StatusBadRequest); return }
    if err := s.deps.Action.Unblock(r.Context(), req.IP, req.Reason); err != nil { http.Error(w, err.Error(), http.StatusInternalServerError); return }
    w.WriteHeader(http.StatusNoContent)
}
